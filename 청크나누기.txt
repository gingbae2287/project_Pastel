1. 블록의 각 면들중 보이는 면만 로딩하는 기능은 아직 X.
 블록 통채로 로딩할 예정. (간편)


2. 블록이 19000여개이다. 한개의 크기는 1.5m 16x16 (갯수) 범위만큼 한 청크로 담는다.


3. 모든 블록을 생성해놓고 setactive로만 바꿔줄지. or 좌표마다 블록 정보를 bool로 저장후 그때그때 loading unloading 해줄지 선택.

3.2 
블록 단위로 매번 체크해서 로딩 un로딩 해주는것은 비효율 적이라 생각.

3.1 setactive 
각 청크는 빈 오브젝트로 좌표만 존재. 자식으로 각 블록들을 할당. (처음 맵 생성시 할당후 setactive false)
2차원의 청크 오브젝트 배열과 "bool isChunkLoad"배열을 만든다. 맵의 크기가 정해져 있기 때문에 배열크기는 바로 할당.
0,0 좌표를 시작으로 15,15 까지가 chunk[0][0], 16,0~31,15 는 chunk[1][0] ... 으로 자식 할당.

///완성////

플레이어의 좌표 정보를 매번 받아와 근처 청크들 로딩.
- 플레이어가 있는 청크 번호 변수 두개(x,z)
-매번 플레이어 좌표 /16 한 번호랑 체크해서 달라지면 활성청크 바꾸기 함수 실행

각 청크의 시작 좌표는 16의 배수 이므로. 플레이어의 좌표 (실제좌표/1.5를 해주자. 블록한개 1.5m가 좌표기준 1로 잡음)를 16으로 나눈 몫을 a라고 하면.

a-2~a+2 까지의 청크 로딩. (범위는 차차테스트) x, z좌표에 모두 시행해준다.
그럼 총 25개의 청크가 로딩. 16x16x25=6400


ㅁㅁㅁㅁㅁ
ㅁㅁㅁㅁㅁ
ㅁㅁㅅㅁㅁ
ㅁㅁㅁㅁㅁ
ㅁㅁㅁㅁㅁ

==>> 청크의 크기를 줄이자. or a-1~a+1

1.청크크기 줄이기. 8x8로 줄일시 8x8x25=1600개 블록 . chunk 개수 4배로 늘어남.

2. 로딩 청크 범위 줄이기. a-1 ~ a+1

ㅁㅁㅁ
ㅁㅅㅁ
ㅁㅁㅁ

16x16x9=2304 블록. 

현재 청크 개수는 맵이 한정되어 많지 않고 로드,언로드시에만 사용되기 때문에 청크개수 4배로 늘어나는건 큰 문제 없다고 생각.
1번 선택.

==========================================================================
기존에 로딩된 청크는 어떻게 언로딩 할까.?
1. 모든 청크에 대해 플레이어 좌표로 부터 로딩범위에 해당되지않으면 언로딩, isChunkLoad=false
2. 새로 로딩된 청크를 확인해 반대방향에있는 청크 unload

1번의 경우 간단. 지금은 청크개수가 많지않아 메모리 부하가 적을것. (무한맵이 아니기때문)
새 청크 로딩시에만 언로딩 check 진행

2번의경우. 새로 로딩된청크의 좌표-플레이어 좌표를 한 값의 부호로 방향을 계산해 반대방향의 청크 unloading  ==> 맵의 끝에서 청크 배열 참조시 주의 (오버플로우)

청크정보는 isChunkLoad 의 bool타입만 있기 때문에 1번으로 진행해도 될듯.






